# Алгоритм Дейкстры

## Случай для плотного графа
Создадим такие массивы
1. ```dist``` — размером $v+1$. В нем для каждой вершины хранится текущая длина кратчайшего пути от начальной вершины $s$. (```d[s] = 0```, а все остальное — ```inf```)
2. ```visited``` — размером $v+1$. Хранит иформацию о том, обработана вершина или нет

Алгоритм состоит из $v-1$ шага. На каждом шаге делаем следующее
1. Выбираем необработанную вершину $v$ с минимальным расстоянием от начальной вершины. Помечаем $v$ как обработанную
2. Производим релаксацию: рассматриваем все вершины, соседние с $v$ (вес ребра $(u,v)=w$) и для соседней вершины $u$ пытаемся улучшить значение ```dist[u]```, т.е. ```dist[u]=min(dist[u], dist[v]+w)```

### Сложность
**Со списком смежности** — $O(V^2+E)$, так как мы на каждом из $v-1$ шагов ищем минимум из $V$ чисел для вершин и просматриваем каждое ребро один раз

**С матрицей смежности** — $O(V^2)$

## Случай для разряженного графа
***Reminder:*** Разряженным называется граф, у которого количество ребер значительно меньше, чем $V^2$

Алгоритм Дейкстры для разреженных графов работает следующим образом:
1.  Инициализация:
    - Задаётся начальная вершина, от которой будут рассчитываться кратчайшие пути
    - Все расстояния до остальных вершин инициализируются как бесконечность, кроме начальной вершины, для которой расстояние равно нулю
    - Создаётся структура данных, например, ```ordered set``` или куча, для хранения и быстрого доступа к вершинам и их текущим кратчайшим расстояниям

2. Пока есть непосещённые вершины:
    - Выбирается вершина с минимальным текущим расстоянием (с использованием кучи или ```ordered set```)
    - Эта вершина помечается как посещённая
    - Для каждой соседней вершины, смежной с текущей:
        * Рассчитывается новое потенциальное расстояние как сумма текущего расстояния до рассматриваемой вершины и веса ребра между текущей вершиной и соседней
        * Если новое расстояние меньше известного расстояния до соседней вершины:
            - Обновляется расстояние до соседней вершины
            - В ```ordered set``` или куче обновляется информация о расстоянии до этой вершины
3. Обновление структуры данных:
    - При обновлении расстояний до соседних вершин, в структуре данных (куче или ```ordered set```) происходит операция удаления старого значения и добавления нового значения, что обеспечивает эффективность алгоритма
    - В случае использования кучи без изменения элементов (например, ```priority queue```) просто добавляются новые значения, а устаревшие игнорируются

Процесс повторяется, пока не будут посещены все вершины или не будут определены кратчайшие пути до всех достижимых вершин


### Сложность
$O(E\log{V} + V\log{V})$. Узнаем минимум за $O(1)$ (удаление минимума тратит $O(\log{V})$), изменяем элементы за $O(\log{V})$. Для большинства графов сложность будет просто $O(E\log{V})$, так как каждое из $E$ ребер может привести к уменьшению пути и изменению значения в ```set```

В итоге массив расстояний содержит кратчайшие пути от начальной вершины до всех остальных вершин