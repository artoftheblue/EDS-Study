# Задача union-find
Пусть у нас есть $N$ элементов, занумерованных от 1 до $N$

Изначально каждый элемент находится в своем отдельном множестве (также занумерованных от 1 до $N$). Нам необходимо поддерживать такие операции:
1. ```find(x)``` — найти номер множетсва, в котором лежит $x$
2. ```union(x, y)``` — объединить множества, содержащие $x$ и $y$
3. Можно добавить, но необязательно:
    - ```make(x)``` — создает новое множество, содержащее $x$ 


## Наивная реализация
1. Создаем массив с индексами от 1 до $N$
    - Индекс означает номер элемента
    - Значение по индексу — номер множества, к которому относится элемент
2. Операция ```find(x)```
    - Нужно вернуть содержимое ячейки с номером $x$
    - **Сложность** — $O(1)$
3. Операция ```union(x, y)```
    - Узнаем номера множеств, содеражащих эти элементы (пусть это $a$ и $b$ соответственно)
    - Проходим по всему массиву и заменяем значения $b$ на $a$
    - **Сложность одной операции** — $O(N)$
    - **Сложность объединения всех множеств** — $O(N^2)$

## Реализация с использованием линейных списков
Идея этой реализации заключается в том, что мы заводим второй масиив, на индексах которого стоят номера множеств, а по индексу хранится список элементов соответствующего множества

Тогда при вызове ```union(x, y)``` мы делаем так: ```max(x, y) += min(x, y)```

### Сложность
Так как мы храним второй масиив, то мы *теряем в памяти*, однако алгоритм будет работать *быстрее*, за $O(N\log N)$, так как делаем $O(\log N)$ шагов на кажом шаге $O(N)$ для объединения множеств


## Система непересекающихся множеств
Идея заключается в хранении каждого множества в виде дерева

Мы имеем один единственный массив предков ```p```. Индексы в нем — номера элементов, а по индексу хранится номер предка

Тогда операции ```find(x)``` и ```union(x, y)``` можно реализовать так:

```cpp
int find(x){
    while (p[v] != -1){
        v = p[v]
    }
    return v
}

void union(x, y){
    p[find(x)] = find(y)
}
```
**Сложность** — $O(N^2)$

### Сжатие путей
Идея заключается в том, что когда мы найдём искомого предка $p$ множества (с помощью ```find(x)```), то запомним, что у вершины $x$ и всех пройденных по пути вершин — именно этот предок $p$. Проще всего это сделать, перенаправив их ```parent[]``` на эту вершину $p$

Теперь в массиве предков для каждой вершины там может храниться не непосредственный предок, а предок предка, предок предка предка, и т.д

**Сложность** — $O(\log N)$

### Объединение деревьев
Идея: нужно подвешивать дерево с большей глубиной к дереву с меньшей глубиной

Для каждого дерева храним его глубину в массиве

**Сложность** — $O(\log N)$
