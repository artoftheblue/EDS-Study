# Дерево поиска

***Бинарное дерево поиска*** — дерево, для которого выполняются
следующие свойства:

-   У каждой вершины не более двух детей

-   Все вершины обладают *ключами*, на которых определена операция
    сравнения (например, целые числа или строки)

-   У всех вершин *левого* поддерева вершины $v$ ключи *не больше*, чем
    ключ $v$

-   У всех вершин *правого* поддерева вершины $v$ ключи *больше*, чем
    ключ $v$

-   Оба поддерева — левое и правое — являются двоичными деревьями
    поиска

В *небинарных* деревьях количество детей может быть
больше двух, и при этом в «более левых» поддеревьях ключи должны быть
меньше, чем «более правых»

Для работы с деревьями поиска нужно создать структуру

    struct Node:
      T key                    // key of the node
      Node left                // pointer to the left child
      Node right               // pointer to the right child
      Node parent              // pointer to the parent

## Поиск элемента

Нужна функция, прнимающая корень дерева и искомый ключ

-   Для каждого узла сравниваем значение его ключа с искомым ключом

-   Если ключи одинаковы, то функция возвращает текущий узел

-   В противном случае функция вызывается рекурсивно для левого или
    правого поддерева

<!-- -->

    Node search(x : Node, k : T):
       if x == null or k == x.key
          return x
       if k < x.key
          return search(x.left, k)
       else
          return search(x.right, k)

### Сложность в худшем случае 
$O(h)$ ($h$ — высота дерева), так
как узлы, которые посещает функция образуют нисходящее дерево. Такое
возможно, когда дерево является «бамбуком»

### Сложность при оптимизации
$O(\log N)$. Если изменить способ
хранения дерева, например сразу при проходе до какого-то ключа записать
его как ключ ко всем вершинам в пути, то сложность снизится

## Вставка элемента

Почти то же самое, что поиск элемента, но теперь при обнаружении у
элемента отсутствия ребенка нужно подвесить на него вставляемый элемент

    Node insert(x : Node, z : T):               // x - root of the subtree, z - key to be inserted
       if x == null 
          return Node(z)                        // attach a Node with key = z
       else if z < x.key
          x.left = insert(x.left, z)
       else if z > x.key
          x.right = insert(x.right, z)
       return x

## Удаление элемента

Рассмотрим три случая при рекурсивной реализации

1.  Удаляемый элемент находится в *левом* поддереве текущего поддерева

    -   тогда нужно рекурсивно удалить элемент из нужного поддерева

2.  Удаляемый элемент находится в *правом* поддереве

    -   тогда нужно рекурсивно удалить элемент из нужного поддерева

3.  Удаляемый элемент находится в *корне*, то два случая:

    -   имеет два дочерних узла

        -   нужно заменить его минимальным элементом из правого
            поддерева и рекурсивно удалить этот минимальный элемент из
            правого поддерева

    -   имеет один дочерний узел

        -   нужно заменить удаляемый элемент потомком

<!-- -->

    Node delete(root : Node, z : T):    // root of subtree, key to delete
      if root == null
        return root
      if z < root.key
        root.left = delete(root.left, z)
      else if z > root.key
        root.right = delete(root.right, z)
      else if root.left != null and root.right != null
        root.key = minimum(root.right).key
        root.right = delete(root.right, root.key)
      else
        if root.left != null
          root = root.left
        else if root.right != null
          root = root.right
        else
          root = null
      return root