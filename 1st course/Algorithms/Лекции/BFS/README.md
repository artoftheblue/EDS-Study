# Breadth first search (BFS)

## Наивный алгоритм
Создаем массив, заполняем его бесконечностью ($v+1$, например). Для начальной вершины установим значение $0$

Выполняем $v-1$ шагов. Нужно перебрать все вершины и выбрать те, которые находятся на расстоянии равном номеру шага, а также пометить все соседние вершины числом на $1$ большим, чем номер текущего шага

1. На нулевом шаге выбираем начальную вершину и помечаем ее соседей $1$
2. Затем выбираем вершины, находящиеся на расстоянии $1$ и их непомечанных соседей помечаем $2$ и т.д.

### Сложность
$O(V^2+E)$, так как мы сделаем $V$ шагов, переберем $V$ вершин, а также просмотрим все ребра

## Реализация через очередь
В начале очереди находятся вершины текущего шага, а в конце — следующего

1. Помещаем начальную вершину в очередь, а в масив расстояний ставим 0 для нее
2. Берем первый (верхний) элемент из очереди и просматриваем соседей
3. Если сосед не посещался, то добавляем его в очередь, помечаем вершину как посещенную
4. Если сосед является пунктом назначения, алгоритм завершает работу

### Время работы
$O(V+E)$

## Применение алгоритма
1. Для поиска кратчайшего пути в неявно заданных и невзвешенных графах
2. Для обнаружения кратчайших путей и минимальных покрывающих деревьев


