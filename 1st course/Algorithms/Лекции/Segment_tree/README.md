# Дерево отрезков

## Дерево отрезков

Дан массив $a$ из $n$ целых чисел, и требуется отвечать на запросы двух
типов:

1.  Изменить значение в ячейке (т. е. реагировать на присвоение
    ```a[k] = x```)

2.  Вывести сумму элементов $a_i$ на отрезке с $l$ по $r$

Несколько изменим массив

-   Посчитаем сумму всего массива и где-нибудь запишем

-   Разделим его пополам, посчитаем сумму на половинах и тоже где-нибудь
    запишем

-   Каждую половину разделим пополам ещё раз, и т.д., пока не придём к
    отрезкам длины 1


Корень дерева соответствует отрезку $[0, n)$, а каждая вершина (не
считая листьев) имеет ровно двух сыновей, которые тоже соответствуют
каким-то отрезкам

## Операции на отрезке

Здесь представлены операции на отрезке, реализованные с помощью
указателей. Эта реализация не самая эффективная, но самая простая,
решающая большинство задач. Подробнее о других реализациях
[тут](http://e-maxx.ru/algo/segment_tree) и
[тут](https://codeforces.com/blog/entry/18051)

### Построение

Строить дерево отрезков можно рекурсивным конструктором, который создает
детей, пока не доходит до листьев\
Если изначально массив не нулевой, то можно параллельно с проведением
ссылок насчитывать суммы

**Сложность** — $O(n)$
```cpp
Segtree(int lb, int rb) : lb(lb), rb(rb) {
    if (lb + 1 == rb)
        s = a[lb];
    else {
        int t = (lb + rb) / 2;
        l = new Segtree(lb, t);
        r = new Segtree(t, rb);
        s = l->s + r->s;
    }
}
```
### Изменение

Для запроса прибавления будем рекурсивно спускаться вниз, пока не дойдем
до листа, соответствующего элементу $k$, и на всех промежуточных
вершинах прибавим $x$:

```cpp
void add(int k, int x) {
    s += x;
    if (l){
        if (k < l->rb)
            l->add(k, x);
        else
            r->add(k, x);
    }
}
```
**Сложность** — $O(\log n)$

### Сумма

Нужно делать разбор случаев, как отрезок запроса пересекается с отрезком
вершины:

1.  Если лежит полностью в отрезке запроса, вывести сумму

2.  Если не пересекается с отрезком запроса, вывести ноль

3.  else: рекурсивно запускаемся от детей


```cpp
int sum(int lq, int rq) {
    if (lb >= lq && rb <= rq)
        return s;
    if (max(lb, lq) >= min(rb, rq))
        return 0;
    return l->sum(lq, rq) + r->sum(lq, rq);
}
```
**Сложность** — $O(\log n)$. На каждом уровне дерева отрезков, наша
рекурсивная функция могла посетить максимум четыре отрезка; тогда,
учитывая оценку $O (\log n)$ для высоты дерева, мы получаем асимптотику
времени работы алгоритма

## Применение дерева отрезков

Дерево отрезков может применяться в таких задачах, как

-   поиск суммы на подотрезке

-   поиск минимума/максимума на отрезкее

-   массовые изменения массивов (например, добавление элемента ко всем
    элементам сразу)
